<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ARPG（剣・爆弾・敵SVG・モバイル対応）</title>
<style>
:root { color-scheme: dark; --fg:#ddd; --bg:#000; --panel:#1b1b1b; --line:#444; }
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
#wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:10px 10px 120px}
canvas#game{background:var(--panel);border:1px solid var(--line);image-rendering:pixelated;width:min(100vw,880px);height:auto;max-height:calc(100vh - 260px);border-radius:8px}
.ui{font-size:14px;width:100%;max-width:900px}
.row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
kbd{border:1px solid #666;border-bottom-width:2px;border-radius:4px;padding:0 4px;background:#151515;color:#ccc;font-weight:600}

/* タッチ操作 */
.touch{
  position:fixed;left:0;right:0;bottom:0;padding:10px 14px calc(10px + env(safe-area-inset-bottom));
  display:flex;justify-content:space-between;align-items:flex-end;gap:12px;
  background:linear-gradient(180deg,rgba(0,0,0,0) 0%,rgba(0,0,0,.55) 40%,rgba(0,0,0,.7) 100%);z-index:10;user-select:none
}
.btn{appearance:none;border:1px solid #3a475a;background:#1f2733;color:#fff;border-radius:14px;padding:0 14px;height:64px;min-width:64px;font-size:16px;font-weight:700;box-shadow:0 2px 0 #000 inset,0 2px 8px rgba(0,0,0,.35);touch-action:manipulation}
.btn:active{background:#2a3650;transform:translateY(1px)}
.dpad{display:flex;flex-direction:column;gap:10px}
.dpad .row-mid{display:flex;gap:10px;justify-content:center}
.btn-dir{width:72px;height:72px;font-size:20px}
.actions{display:flex;flex-direction:column;gap:10px;align-items:flex-end}
.row-actions{display:flex;gap:10px}
.btn-act{min-width:92px}
.items{display:flex;gap:8px}
.btn-item{min-width:72px;opacity:.85}
.btn-item.is-active{outline:2px solid #7aa0ff;opacity:1}
.row-etc{display:flex;gap:8px}
.btn-etc{min-width:56px}

/* 小さな端末で縮小 */
@media (max-width:360px){
  .btn{height:56px;min-width:56px;font-size:15px}
  .btn-dir{width:64px;height:64px}
  canvas#game{width:100vw}
}
/* PCではタッチUI非表示 */
@media (min-width:900px){ .touch{display:none} }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="640" height="384" aria-label="ゲーム画面"></canvas>
  <div class="ui">
    <div class="row">
      移動 <kbd>↑↓←→</kbd>／剣 <kbd>Space</kbd>／使用（爆弾）<kbd>Z</kbd>／再開 <kbd>R</kbd>
    </div>
    <div class="row">
      スライム＝接近、コウモリ＝速い、アーチャー＝直線射撃。倒れたらRで再開。
    </div>
    <div id="hud"></div>
  </div>
</div>

<!-- モバイル用タッチ操作 -->
<div class="touch" aria-label="タッチ操作">
  <div class="dpad" aria-label="方向キー">
    <button id="btn-up" class="btn btn-dir" aria-label="上">▲</button>
    <div class="row-mid">
      <button id="btn-left" class="btn btn-dir" aria-label="左">◀</button>
      <button id="btn-right" class="btn btn-dir" aria-label="右">▶</button>
    </div>
    <button id="btn-down" class="btn btn-dir" aria-label="下">▼</button>
  </div>

  <div class="actions" aria-label="アクション">
    <div class="row-actions">
      <button id="btn-attack" class="btn btn-act" aria-label="攻撃">攻撃</button>
      <button id="btn-use" class="btn btn-act" aria-label="使用">使用</button>
    </div>
    <div class="items" role="group" aria-label="アイテム">
      <button id="btn-bomb" class="btn btn-item is-active">爆弾</button>
    </div>
    <div class="row-etc">
      <button id="btn-reset" class="btn btn-etc" title="リセット(R)">R</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== 基本 =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  const HUD = document.getElementById('hud');

  const TILE=32, COLS=20, ROWS=12;

  // --- マップ（壁だけの簡易ダンジョン）
  const T={ FLOOR:0, WALL:1 };
  const map = Array.from({length:ROWS},(_,y)=>
    Array.from({length:COLS},(_,x)=> (y===0||y===ROWS-1||x===0||x===COLS-1)?T.WALL:T.FLOOR)
  );
  for(let x=4;x<16;x++) map[5][x]=T.WALL;
  for(let y=2;y<10;y++) map[y][12]=T.WALL;

  const inB=(x,y)=> x>=0&&y>=0&&x<COLS&&y<ROWS;
  const solid=(x,y)=> !inB(x,y) || map[y][x]===T.WALL;
  const passable=(x,y)=> inB(x,y) && map[y][x]!==T.WALL;

  // --- プレイヤー
  const player={x:2,y:2,hp:6,item:'bomb',facing:'right',moveDelay:0,atkCD:0,useCD:0,alive:true};

  // --- 敵・弾・爆弾・斬撃
  const enemies=[];      // {type,x,y,hp,cd,moveTick}
  const projectiles=[];  // {x,y,dx,dy,ttl,from}
  const bombs=[];        // {x,y,timer}
  const slashEffects=[]; // {x,y,dir,t}
  const rng=Math.random;

  // --- 入力
  const keys={};
  addEventListener('keydown',e=>{
    keys[e.key]=true;
    if([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
    if(e.key==='r' || e.key==='R') reset();
  },{passive:false});
  addEventListener('keyup',e=>{ keys[e.key]=false; });

  // --- タッチ割当
  const bindHold=(el,key)=>{
    const set=v=>{keys[key]=v};
    const down=e=>{e.preventDefault(); set(true); navigator.vibrate?.(10);};
    const up=()=> set(false);
    el.addEventListener('pointerdown',down,{passive:false});
    ['pointerup','pointerleave','pointercancel'].forEach(t=> el.addEventListener(t,up));
  };
  bindHold(document.getElementById('btn-up'),'ArrowUp');
  bindHold(document.getElementById('btn-down'),'ArrowDown');
  bindHold(document.getElementById('btn-left'),'ArrowLeft');
  bindHold(document.getElementById('btn-right'),'ArrowRight');
  bindHold(document.getElementById('btn-attack'),' ');
  bindHold(document.getElementById('btn-use'),'z');
  document.getElementById('btn-reset').addEventListener('pointerdown',e=>{e.preventDefault(); reset();});

  // ===== SVG（プレイヤー＆敵＆HUD） =====
  const heroSVG = `
<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
  <ellipse cx="16" cy="27" rx="8" ry="3" fill="#000" opacity=".25"/>
  <path d="M6 18 Q16 30 26 18 L22 14 L10 14 Z" fill="#90caf9" stroke="#2b3d57" stroke-width="1.5"/>
  <rect x="11" y="14" width="10" height="8" rx="2" fill="#6ec6a8" stroke="#2e6b5b" stroke-width="1.5"/>
  <rect x="11" y="22" width="4" height="5" rx="1" fill="#5a4638"/>
  <rect x="17" y="22" width="4" height="5" rx="1" fill="#5a4638"/>
  <circle cx="16" cy="11" r="7" fill="#ffe0b2" stroke="#333" stroke-width="1.8"/>
  <path d="M9 11 Q16 4 23 11 L23 9 Q16 2 9 9 Z" fill="#8bc34a" stroke="#2b5d1f" stroke-width="1.5"/>
  <circle cx="13" cy="11" r="1.4" fill="#333"/>
  <circle cx="19" cy="11" r="1.4" fill="#333"/>
  <path d="M13 14 Q16 16 19 14" stroke="#d66" stroke-width="1.6" fill="none" stroke-linecap="round"/>
</svg>`;

  const slimeSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <path d="M4 22 Q16 6 28 22 Q28 28 4 28 Z" fill="#7cc37c" stroke="#3c8c3c" stroke-width="2"/>
  <circle cx="12" cy="18" r="2" fill="#2b5d2b"/><circle cx="20" cy="18" r="2" fill="#2b5d2b"/>
  <path d="M12 22 Q16 24 20 22" stroke="#2b5d2b" stroke-width="2" fill="none" stroke-linecap="round"/></svg>`;

  const batSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <path d="M2 18 Q8 10 16 16 Q24 10 30 18 L22 18 Q16 24 10 18 Z" fill="#b0b0ff" stroke="#6666aa" stroke-width="2"/>
  <circle cx="16" cy="16" r="3" fill="#e0e0ff"/></svg>`;

  const archerSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <rect x="10" y="12" width="12" height="12" rx="3" fill="#d1c08a" stroke="#8a7a4a" stroke-width="2"/>
  <circle cx="16" cy="10" r="4" fill="#e8d8a0" stroke="#8a7a4a" stroke-width="2"/>
  <path d="M8 12 Q4 20 8 28" stroke="#6b4f2e" stroke-width="3" fill="none"/>
  <path d="M8 16 L18 20" stroke="#6b4f2e" stroke-width="2"/></svg>`;

  const heartSVG  = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M16 29s-13-8-13-17c0-5 4-9 9-9 3 0 6 2 8 4 2-2 5-4 8-4 5 0 9 4 9 9 0 9-13 17-13 17z" fill="#e53935" stroke="#b71c1c" stroke-width="2"/></svg>`;
  const bombSVG   = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><circle cx="16" cy="20" r="10" fill="#212121" stroke="#424242" stroke-width="2"/><rect x="14" y="6" width="4" height="6" fill="#757575" stroke="#424242" stroke-width="2"/><path d="M16 4 Q18 0 22 2" stroke="#ffb300" stroke-width="2" fill="none"/></svg>`;

  const svgImg = (svg)=>{ const img=new Image(); img.src='data:image/svg+xml;utf8,'+encodeURIComponent(svg); return img; };
  const heroImg    = svgImg(heroSVG);
  const imgs = { slime:svgImg(slimeSVG), bat:svgImg(batSVG), archer:svgImg(archerSVG), heart:svgImg(heartSVG), bomb:svgImg(bombSVG) };

  // ===== 初期スポーン =====
  function spawn(){
    enemies.length=0; projectiles.length=0; bombs.length=0; slashEffects.length=0;
    const place=()=>{let x,y; do{ x=1+Math.floor(rng()*(COLS-2)); y=1+Math.floor(rng()*(ROWS-2)); }while(!passable(x,y)||(x===player.x&&y===player.y)); return {x,y};};
    player.x=2; player.y=2; player.hp=6; player.alive=true; player.facing='right';

    for(let i=0;i<2;i++){ const p=place(); enemies.push({type:'slime',x:p.x,y:p.y,hp:2,cd:0,moveTick:0}); }
    for(let i=0;i<2;i++){ const p=place(); enemies.push({type:'bat',x:p.x,y:p.y,hp:1,cd:0,moveTick:0}); }
    { const p=place(); enemies.push({type:'archer',x:p.x,y:p.y,hp:2,cd:800,moveTick:0}); }
  }

  // ===== 剣・爆弾・共通 =====
  function tryMove(dx,dy){
    if(player.moveDelay>0 || !player.alive) return;
    const nx=player.x+dx, ny=player.y+dy;
    player.facing = dx>0?'right':dx<0?'left':dy>0?'down':'up';
    if(passable(nx,ny)){ player.x=nx; player.y=ny; player.moveDelay= 120; }
  }

  function swordCells(px,py,dir){
    if(dir==='right') return [[px+1,py],[px+1,py-1],[px+1,py+1]];
    if(dir==='left')  return [[px-1,py],[px-1,py-1],[px-1,py+1]];
    if(dir==='down')  return [[px,py+1],[px-1,py+1],[px+1,py+1]];
    return [[px,py-1],[px-1,py-1],[px+1,py-1]]; // up
  }
  function dirVec(dir){ return dir==='right'?[1,0]:dir==='left'?[ -1,0 ]:dir==='down'?[0,1]:[0,-1]; }

  function attack(){
    if(player.atkCD>0 || !player.alive) return; 
    player.atkCD=220;

    const cells = swordCells(player.x,player.y,player.facing);
    const [kdx,kdy] = dirVec(player.facing);

    // 斬撃エフェクト
    slashEffects.push({x:player.x,y:player.y,dir:player.facing,t:140});

    // ヒット判定
    for(const e of enemies){
      if(e.hp<=0) continue;
      if(cells.some(([x,y])=> x===e.x && y===e.y)){
        e.hp--;
        // ノックバック
        const nx=e.x+kdx, ny=e.y+kdy;
        if(passable(nx,ny)) { e.x=nx; e.y=ny; }
      }
    }
  }

  function useItem(){
    if(player.useCD>0 || !player.alive) return; player.useCD=260;
    if(bombs.some(b=>b.x===player.x&&b.y===player.y)) return;
    bombs.push({x:player.x,y:player.y,timer:900});
  }

  function explode(b){
    const cells=[[0,0],[1,0],[-1,0],[0,1],[0,-1]].map(([dx,dy])=>[b.x+dx,b.y+dy]);
    enemies.forEach(e=>{
      if(e.hp<=0) return;
      if(cells.some(([x,y])=> x===e.x && y===e.y)) e.hp--;
    });
    if(cells.some(([x,y])=> x===player.x && y===player.y)) hurt(1);
  }

  function shoot(from,dx,dy,ttl=1500){ projectiles.push({x:from.x,y:from.y,dx,dy,ttl,from}); }
  function clearLine(x0,y0,x1,y1){
    if(x0===x1){ const a=Math.min(y0,y1), b=Math.max(y0,y1); for(let y=a+1;y<b;y++) if(solid(x0,y)) return false; return true; }
    if(y0===y1){ const a=Math.min(x0,x1), b=Math.max(x0,x1); for(let x=a+1;x<b;x++) if(solid(x,y0)) return false; return true; }
    return false;
  }

  function hurt(n){
    if(!player.alive) return;
    player.hp=Math.max(0,player.hp-n);
    if(player.hp===0) player.alive=false;
  }

  function reset(){ spawn(); }

  // ===== 更新 =====
  let last=performance.now();
  function update(now){
    const dt=now-last; last=now;
    if(player.moveDelay>0) player.moveDelay-=dt;
    if(player.atkCD>0) player.atkCD-=dt;
    if(player.useCD>0) player.useCD-=dt;

    // 入力
    if(keys['ArrowLeft']) tryMove(-1,0);
    else if(keys['ArrowRight']) tryMove(1,0);
    else if(keys['ArrowUp']) tryMove(0,-1);
    else if(keys['ArrowDown']) tryMove(0,1);
    if(keys[' ']) attack();
    if(keys['z']||keys['Z']) useItem();

    // 斬撃エフェクト更新
    for(const s of slashEffects){ s.t-=dt; }
    for(let i=slashEffects.length-1;i>=0;i--) if(slashEffects[i].t<=0) slashEffects.splice(i,1);

    // 敵AI
    for(const e of enemies){
      if(e.hp<=0) continue;
      e.moveTick=(e.moveTick||0)-dt;
      const base = e.type==='bat'? 260 : e.type==='slime'? 520 : 680;
      if(e.moveTick<=0){
        e.moveTick=base;
        const dx=Math.sign(player.x-e.x), dy=Math.sign(player.y-e.y);
        const order = Math.random()<.5? [[dx,0],[0,dy]] : [[0,dy],[dx,0]];
        for(const [mx,my] of order){
          const nx=e.x+mx, ny=e.y+my;
          if(passable(nx,ny)){ e.x=nx; e.y=ny; break; }
        }
      }
      if(Math.abs(e.x-player.x)+Math.abs(e.y-player.y)===1 && Math.random()<.08) hurt(1);

      if(e.type==='archer'){
        e.cd=(e.cd||0)-dt;
        if(e.cd<=0){
          if(e.x===player.x && clearLine(e.x,e.y,player.x,player.y)){
            const dy=Math.sign(player.y-e.y); shoot(e,0,dy,1600); e.cd=1200;
          }else if(e.y===player.y && clearLine(e.x,e.y,player.x,player.y)){
            const dx=Math.sign(player.x-e.x); shoot(e,dx,0,1600); e.cd=1200;
          }else{
            e.cd=500;
          }
        }
      }
    }

    // 弾更新
    for(const p of projectiles){
      p.ttl-=dt; if(p.ttl<=0){ p.dead=true; continue; }
      p.st=(p.st||0)+dt;
      while(p.st>=50){
        p.st-=50;
        const nx=p.x+p.dx, ny=p.y+p.dy;
        if(!passable(nx,ny)){ p.dead=true; break; }
        p.x=nx; p.y=ny;
        if(nx===player.x && ny===player.y){ hurt(1); p.dead=true; break; }
      }
    }
    // 爆弾
    for(const b of bombs){ b.timer-=dt; if(b.timer<=0){ explode(b); b.dead=true; } }

    // 片付け
    for(let i=projectiles.length-1;i>=0;i--) if(projectiles[i].dead) projectiles.splice(i,1);
    for(let i=bombs.length-1;i>=0;i--) if(bombs[i].dead) bombs.splice(i,1);

    // HUD
    const aliveTxt = player.alive? '生存中' : '倒れました（Rで再開）';
    HUD.textContent = `HP:${player.hp}　敵:${enemies.filter(e=>e.hp>0).length}　状態:${aliveTxt}`;
  }

  // ===== 描画 =====
  function draw(){
    ctx.fillStyle='#0a0a0a'; ctx.fillRect(0,0,canvas.width,canvas.height);

    // タイル
    for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
      if(map[y][x]===T.FLOOR){
        ctx.fillStyle='#222'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
      }else{
        ctx.fillStyle='#484848'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        ctx.fillStyle='#3a3a3a'; ctx.fillRect(x*TILE+6,y*TILE+6,TILE-12,TILE-12);
      }
    }

    // 爆弾
    for(const b of bombs){
      if(imgs.bomb.complete) ctx.drawImage(imgs.bomb, b.x*TILE, b.y*TILE, TILE, TILE);
      else { ctx.fillStyle='#222'; ctx.fillRect(b.x*TILE+8,b.y*TILE+8,16,16); }
    }

    // プレイヤー
    if(heroImg.complete){
      ctx.drawImage(heroImg, player.x*TILE, player.y*TILE, TILE, TILE);
    }else{
      ctx.fillStyle='#7be0ff'; ctx.fillRect(player.x*TILE+8,player.y*TILE+8,16,16);
    }

    // 斬撃エフェクト（半透明扇）
    for(const s of slashEffects){
      ctx.save();
      ctx.globalAlpha = Math.max(0, s.t/140) * 0.6;
      ctx.fillStyle = '#cfe8ff';
      const px = player.x*TILE + 16, py = player.y*TILE + 16;
      ctx.translate(px,py);
      const ang = s.dir==='right'?0 : s.dir==='down'?Math.PI/2 : s.dir==='left'?Math.PI : -Math.PI/2;
      ctx.rotate(ang);
      ctx.beginPath();
      ctx.moveTo(8, -14);
      ctx.quadraticCurveTo(28, -6, 28, 0);
      ctx.quadraticCurveTo(28, 6, 8, 14);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // 敵
    for(const e of enemies){
      if(e.hp<=0) continue;
      let img = e.type==='slime'? imgs.slime : e.type==='bat'? imgs.bat : imgs.archer;
      if(img.complete) ctx.drawImage(img, e.x*TILE, e.y*TILE, TILE, TILE);
      else { ctx.fillStyle='#c66'; ctx.fillRect(e.x*TILE+8,e.y*TILE+8,16,16); }
    }

    // 弾
    ctx.fillStyle='#ff6666';
    for(const p of projectiles){ ctx.fillRect(p.x*TILE+12,p.y*TILE+12,8,8); }

    // HUD（ハート）
    for(let i=0;i<player.hp;i++){
      if(imgs.heart.complete) ctx.drawImage(imgs.heart, 8+i*18, 8, 16, 16);
      else { ctx.fillStyle='#e53935'; ctx.fillRect(8+i*18,8,16,16); }
    }
  }

  // ===== ループ開始 =====
  function loop(ts){ update(ts); draw(); requestAnimationFrame(loop); }
  function start(){ spawn(); requestAnimationFrame(t=>{ last=t; loop(t); }); }
  start();
})();
</script>
</body>
</html>
